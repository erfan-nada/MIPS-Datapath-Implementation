$date
	Fri Dec 20 20:02:01 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module MIPS_Datapath_tb $end
$var wire 1 ! zero $end
$var wire 32 " pc [31:0] $end
$var wire 32 # memDataOut [31:0] $end
$var wire 32 $ aluResult [31:0] $end
$var reg 3 % aluControl [2:0] $end
$var reg 1 & branch $end
$var reg 1 ' clk $end
$var reg 32 ( instruction [31:0] $end
$var reg 1 ) memRead $end
$var reg 1 * memWrite $end
$var reg 1 + regWrite $end
$var reg 1 , reset $end
$scope module uut $end
$var wire 3 - aluControl [2:0] $end
$var wire 1 & branch $end
$var wire 1 . branchTaken $end
$var wire 1 ' clk $end
$var wire 32 / instruction [31:0] $end
$var wire 1 ) memRead $end
$var wire 1 * memWrite $end
$var wire 32 0 pc [31:0] $end
$var wire 1 + regWrite $end
$var wire 1 , reset $end
$var wire 1 ! zero $end
$var wire 32 1 signExtImm [31:0] $end
$var wire 32 2 regData2 [31:0] $end
$var wire 32 3 regData1 [31:0] $end
$var wire 32 4 pc_plus4 [31:0] $end
$var wire 32 5 pc_next [31:0] $end
$var wire 32 6 memDataOut [31:0] $end
$var wire 32 7 branch_target [31:0] $end
$var wire 32 8 branchOffset [31:0] $end
$var wire 32 9 aluResult [31:0] $end
$var wire 32 : aluInput2 [31:0] $end
$var reg 32 ; pc_reg [31:0] $end
$scope module alu $end
$var wire 3 < aluControl [2:0] $end
$var wire 1 ! zero $end
$var wire 32 = in2 [31:0] $end
$var wire 32 > in1 [31:0] $end
$var reg 32 ? result [31:0] $end
$upscope $end
$scope module aluMux $end
$var wire 1 @ sel $end
$var wire 32 A out [31:0] $end
$var wire 32 B in1 [31:0] $end
$var wire 32 C in0 [31:0] $end
$upscope $end
$scope module dataMemory $end
$var wire 32 D address [31:0] $end
$var wire 1 ' clk $end
$var wire 1 ) memRead $end
$var wire 1 * memWrite $end
$var wire 32 E writeData [31:0] $end
$var wire 32 F readData [31:0] $end
$upscope $end
$scope module registerFile $end
$var wire 1 ' clk $end
$var wire 32 G readData1 [31:0] $end
$var wire 32 H readData2 [31:0] $end
$var wire 5 I readReg1 [4:0] $end
$var wire 5 J readReg2 [4:0] $end
$var wire 1 + regWrite $end
$var wire 32 K writeData [31:0] $end
$var wire 5 L writeReg [4:0] $end
$upscope $end
$scope module signExtender $end
$var wire 16 M in [15:0] $end
$var wire 32 N out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b0 N
b0 M
b0 L
bx K
b0 J
b0 I
bx H
bx G
b0 F
bx E
bx D
bx C
b0 B
bx A
0@
bx ?
bx >
bx =
b0 <
b0 ;
bx :
bx 9
b0 8
b100 7
b0 6
b100 5
b100 4
bx 3
bx 2
b0 1
b0 0
b0 /
0.
b0 -
1,
0+
0*
0)
b0 (
0'
0&
b0 %
bx $
b0 #
b0 "
x!
$end
#5
1'
#10
b110000010000100 7
b110000010000000 8
b1100000100000 1
b1100000100000 B
b1100000100000 N
b1100000100000 M
b1 I
b10 J
b11 L
0'
b10 %
b10 -
b10 <
1+
b1000100001100000100000 (
b1000100001100000100000 /
0,
#15
b1000 5
b110000010001000 7
b1000 4
b100 "
b100 0
b100 ;
1'
#20
b1100000010010000 7
b1100000010001000 8
b11000000100010 1
b11000000100010 B
b11000000100010 N
b11000000100010 M
b100 I
b101 J
b110 L
0'
b110 %
b110 -
b110 <
b100001010011000000100010 (
b100001010011000000100010 /
#25
b1100 5
b1100000010010100 7
b1100 4
b1000 "
b1000 0
b1000 ;
1'
#30
b1110000010011100 7
b1110000010010000 8
b11100000100100 1
b11100000100100 B
b11100000100100 N
b11100000100100 M
b11 I
b1 J
b111 L
0'
b0 %
b0 -
b0 <
b11000010011100000100100 (
b11000010011100000100100 /
#35
b10000 5
b1110000010100000 7
b10000 4
b1100 "
b1100 0
b1100 ;
1'
#40
b10000000010100100 7
b10000000010010100 8
b100000000100101 1
b100000000100101 B
b100000000100101 N
b100000000100101 M
b101 I
b100 J
b1000 L
0'
b1 %
b1 -
b1 <
b101001000100000000100101 (
b101001000100000000100101 /
#45
b10100 5
b10000000010101000 7
b10100 4
b10000 "
b10000 0
b10000 ;
1'
#50
b100100 7
b10000 8
bx #
bx 6
bx F
b100 1
b100 B
b100 N
b100 M
b1 I
b0 L
0'
b10 %
b10 -
b10 <
1)
b10001100001001000000000000000100 (
b10001100001001000000000000000100 /
#55
b11000 5
b101000 7
b11000 4
b10100 "
b10100 0
b10100 ;
1'
#60
b111000 7
b100000 8
b1000 1
b1000 B
b1000 N
b1000 M
b101 J
0'
0+
1*
b10101100001001010000000000001000 (
b10101100001001010000000000001000 /
#65
b11100 5
b111100 7
b11100 4
b11000 "
b11000 0
b11000 ;
1'
#70
b0x0xx100 5
b1000100 7
b101000 8
x.
b1010 1
b1010 B
b1010 N
b1010 M
b0 I
b0 J
0'
1&
b1000000000000000000000001010 (
b1000000000000000000000001010 /
#75
bx 5
bx 7
bx 4
b0x0xx100 "
b0x0xx100 0
b0x0xx100 ;
1'
#80
b110000 8
b1100 1
b1100 B
b1100 N
b1100 M
0'
b1000000000000000000000001100 (
b1000000000000000000000001100 /
#85
bx "
bx 0
bx ;
1'
#90
